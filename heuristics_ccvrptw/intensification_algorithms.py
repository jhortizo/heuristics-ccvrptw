from heuristics_ccvrptw.utils import (
    check_routes_are_feasible,
    t_k_i_from_routes,
    calculate_cost_function,
)


def generate_2opt_neighborhood(solution):
    """
    Generate the entire 2-opt neighborhood for all routes in the solution.

    :param solution: List of routes, where each route is a list of customer locations (nodes).
                     Example: solution = [[1, 2, 3], [4, 5, 6, 7]]
    :return: List of neighboring solutions generated by applying 2-opt to each route.
    """
    neighborhood = []

    # Iterate over each vehicle's route in the solution
    for route_idx, route in enumerate(solution):
        route_len = len(route)

        # Iterate over all possible pairs of indices i and j (where j > i)
        for i in range(
            1, route_len - 2
        ):  # i should start at 1 to avoid reversing depot (if depot is index 0)
            for j in range(i + 1, route_len - 1):
                # Create a new copy of the solution to avoid modifying the original one
                new_solution = [r.copy() for r in solution]

                # Apply 2-opt by reversing the subroute between i and j
                new_solution[route_idx][i : j + 1] = reversed(
                    new_solution[route_idx][i : j + 1]
                )

                # Add the new solution to the neighborhood
                neighborhood.append(new_solution)

    return neighborhood


def single_two_opt_intensification(
    initial_routes,
    initial_route_t_k_i,
    initial_routes_cost,
    all_times,
    customers,
    capacity,
):
    # generate the whole neighborhood
    neighborhood = generate_2opt_neighborhood(initial_routes)
    print("Size of neighborhood:", len(neighborhood))

    # eval cost of the neighborhood
    t_k_is = []
    for proposed_routes in neighborhood:
        t_k_i = t_k_i_from_routes(proposed_routes, all_times, customers)
        t_k_is.append(t_k_i)

    costs = [calculate_cost_function(t_k_i) for t_k_i in t_k_is]

    # only keep the ones that are better than the original
    better_routes = [
        proposed_routes
        for proposed_routes, cost in zip(neighborhood, costs)
        if cost < initial_routes_cost
    ]
    # keep also the associated t_k_is
    better_t_k_is = [
        t_k_i for t_k_i, cost in zip(t_k_is, costs) if cost < initial_routes_cost
    ]
    # and the costs
    costs = [cost for cost in costs if cost < initial_routes_cost]

    # sort the better ones by cost
    better_routes = [x for _, x in sorted(zip(costs, better_routes))]
    better_t_k_is = [x for _, x in sorted(zip(costs, better_t_k_is))]
    costs = sorted(costs)

    # check feasibility of those, starting from the best. Once a feasible solution is found, stop.
    for proposed_routes, t_k_i, cost in zip(better_routes, better_t_k_is, costs):
        if check_routes_are_feasible(proposed_routes, t_k_i, customers, capacity):
            print("Improvement!: ", initial_routes_cost, "->", cost)
            return proposed_routes, t_k_i, cost

    # if no routes are feasible, return the initial solution
    return initial_routes, initial_route_t_k_i, initial_routes_cost


def local_search_2opt_intensification(
    initial_routes,
    initial_route_t_k_i,
    initial_routes_cost,
    all_times,
    customers,
    capacity,
    max_iter=100,
):
    best_routes = initial_routes
    best_t_k_i = initial_route_t_k_i
    best_cost = initial_routes_cost

    for iter in range(max_iter):
        print("Iteration:", iter)
        # apply 2-opt intensification
        new_routes, new_t_k_i, new_cost = single_two_opt_intensification(
            best_routes, best_t_k_i, best_cost, all_times, customers, capacity
        )

        # Check for convergence
        if new_cost == best_cost:
            break

        best_routes, best_t_k_i, best_cost = new_routes, new_t_k_i, new_cost

        # TODO: we could try and apply a repair method here, between each neighborhood, to potentially reduce the number 
        # of vehicles further

    return best_routes, best_t_k_i, best_cost
